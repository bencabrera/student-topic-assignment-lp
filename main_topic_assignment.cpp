#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <map>
#include <sstream>
#include <cstdlib>
#include <cstdio>

void display_help()
{
	std::cerr << "USAGE: ./topic_assignment [topic_file] [student_preference_file] [preference_values_file]" << std::endl;
	std::cerr << "[topic_file]: File in which each line contains the name of a topic" << std::endl;
	std::cerr << "[student_preference_file]: File in which each line contains a student. Lines start with a name of the student (without spaces) followed by the topic ids (start at 1 for the first topic) ordered by preference." << std::endl;
	std::cerr << "                           Example: Benjamin 3 2 4 (means that student Benjamin prefers to have topic 3 over 2 over 4)" << std::endl;
	std::cerr << "[preference_values_file]: File in which line n contains one single number specifying how much weight is put on the weight is put on n-th choice of a student" << std::endl;
}

int main(int argc, char *argv[])
{
	if(argc == 2 && (std::string(argv[1]) == "help" || std::string(argv[1]) == "-h" || std::string(argv[1]) == "--help"))
	{
		display_help();
		return 0;
	}

	if(argc != 4)
	{
		std::cerr << "Please provide all needed parameters." << std::endl;
		display_help();
		return 1;
	}

	std::string topics_file_path = argv[1];
	std::string student_file_path = argv[2];
	std::string weight_file_path = argv[3];

	// read in topics
	std::vector<std::string> topic_titles;
	std::ifstream topics_file(topics_file_path);
	std::string topic;
	while(std::getline(topics_file, topic))
	{
		if(!topic.empty())
			topic_titles.push_back(topic);
	}

	// read in student preferences
	std::map<std::string, std::vector<unsigned>> student_preferences;
	std::ifstream student_preferences_file(student_file_path);
	std::string line;
	std::size_t i_line = 1;
	while(std::getline(student_preferences_file, line))
	{
		std::stringstream ss(line);
		std::string student_name;
		std::vector<unsigned> student_topic_preferences;
		ss >> student_name;	
		unsigned preference;
		while(!ss.eof())
		{
			ss >> preference;
			if(preference == 0)
			{
				std::cerr << "Parsing error in student preference file at line " << i_line << std::endl;
				return 1;
			}
			student_topic_preferences.push_back(preference);
		}

		student_preferences.insert({ student_name, student_topic_preferences });

		i_line++;
	}

	for(auto pref : student_preferences)
	{
		std::cout << pref.first << " ";
		for(auto v : pref.second)
			std::cout << v << " ";
		std::cout << std::endl;
	}
	std::cout << "........" << std::endl;



	std::vector<std::pair<std::string, std::vector<unsigned>>> student_preferences_vec(student_preferences.begin(), student_preferences.end());

	// read in weights on preferences
	std::vector<unsigned> weights;
	std::ifstream weight_file(weight_file_path);
	while(!weight_file.eof())
	{
		unsigned weight;	
		weight_file >> weight;
		weights.push_back(weight);
	}

	// build c matrix
	std::vector<std::vector<unsigned>> c_matrix(student_preferences.size(), std::vector<unsigned>(topic_titles.size(), 0));
	std::size_t i_student = 0;
	for(auto student_preference : student_preferences)
	{
		for(std::size_t i_pref = 0; i_pref < student_preference.second.size(); i_pref++)
		{
			c_matrix[i_student][student_preference.second[i_pref]-1] = weights[i_pref];
		}

		i_student++;
	}

	for(std::size_t i_student = 0; i_student < student_preferences.size(); i_student++)
	{
		for(std::size_t i_topic = 0; i_topic < topic_titles.size(); i_topic++)
			std::cout << c_matrix[i_student][i_topic] << " ";
		std::cout << std::endl;
	}

	std::cout << student_preferences.size() << " " << topic_titles.size() << " " << weights.size() << std::endl;

	// --- build lp file ---
	std::ofstream topic_assignment_lp_file("topic_assignment.lp");
	topic_assignment_lp_file << "/* Generated by ./topic_assignment */" << std::endl << std::endl;

	// build target function
	topic_assignment_lp_file << "max: ";
	bool first = true;
	for(std::size_t i_student = 0; i_student < student_preferences.size(); i_student++)
		for(std::size_t i_topic = 0; i_topic < topic_titles.size(); i_topic++)
		{
			if(c_matrix[i_student][i_topic] == 0)
				continue;

			if(first)
				first = false;
			else 
				topic_assignment_lp_file << " + ";

			topic_assignment_lp_file << c_matrix[i_student][i_topic] << " " << "x_" << i_student << "_" << i_topic;
		}
	topic_assignment_lp_file << ";" << std::endl << std::endl;

	// build constraint that each topic is only picked by one student
	topic_assignment_lp_file << "/* constraint that each topic is only picked by one student */" << std::endl << std::endl;
	for(std::size_t i_topic = 0; i_topic < topic_titles.size(); i_topic++)
	{
		first = true;
		for(std::size_t i_student = 0; i_student < student_preferences.size(); i_student++)
		{
			if(first)
				first = false;
			else 
				topic_assignment_lp_file << " + ";

			topic_assignment_lp_file <<  "x_" << i_student << "_" << i_topic;
		}
		topic_assignment_lp_file <<  " = 1;" << std::endl;
	}
	topic_assignment_lp_file << std::endl;

	// build constraint that each student only picks one topic
	topic_assignment_lp_file << "/* build constraint that each student only picks one topic */" << std::endl << std::endl;
	for(std::size_t i_student = 0; i_student < student_preferences.size(); i_student++)
	{
		first = true;
		for(std::size_t i_topic = 0; i_topic < topic_titles.size(); i_topic++)
		{
			if(first)
				first = false;
			else 
				topic_assignment_lp_file << " + ";

			topic_assignment_lp_file <<  "x_" << i_student << "_" << i_topic;
		}
		topic_assignment_lp_file <<  " = 1;" << std::endl;
	}
	topic_assignment_lp_file << std::endl;

	for(std::size_t i_topic = 0; i_topic < topic_titles.size(); i_topic++)
		for(std::size_t i_student = 0; i_student < student_preferences.size(); i_student++)
			topic_assignment_lp_file <<  "bin x_" << i_student << "_" << i_topic << ";" << std::endl;


	// run lp_solve on problem instance and save output to file
	std::system("lp_solve topic_assignment.lp | tail -n +5 > assignment_out.txt");

	// open output file and read it
	std::ifstream result_file("assignment_out.txt");
	std::vector<std::vector<unsigned>> result_matrix(student_preferences.size(), std::vector<unsigned>(topic_titles.size(), 0));
	while(std::getline(result_file, line))
	{
		std::stringstream ss(line);
		std::string variable, value;
		ss >> variable >> value;

		std::stringstream ss2(variable);
		std::string i_student_str, i_topic_str, dump;
		std::getline(ss2, dump, '_');
		std::getline(ss2, i_student_str, '_');
		std::getline(ss2, i_topic_str, '_');

		std::size_t i_student = std::stoul(i_student_str);
		std::size_t i_topic = std::stoul(i_topic_str);

		if(value == "0")
			result_matrix[i_student][i_topic] = 0;
		else
			result_matrix[i_student][i_topic] = 1;
	}

	// check consistency of result_matrix
	for(std::size_t i_student = 0; i_student < student_preferences.size(); i_student++)
	{
		std::size_t n_trues = 0;
		for(std::size_t i_topic = 0; i_topic < topic_titles.size(); i_topic++)
			n_trues += (result_matrix[i_student][i_topic]) ? 1 : 0;
		if(n_trues != 1)
		{
			std::cerr << "Error" << std::endl;
		}
	}

	for(std::size_t i_topic = 0; i_topic < topic_titles.size(); i_topic++)
	{
		std::size_t n_trues = 0;
		for(std::size_t i_student = 0; i_student < student_preferences.size(); i_student++)
			n_trues += (result_matrix[i_student][i_topic]) ? 1 : 0;
		if(n_trues != 1)
		{
			std::cerr << "Error" << std::endl;
			return 1;
		}
	}

	for(std::size_t i_student = 0; i_student < student_preferences.size(); i_student++)
		for(std::size_t i_topic = 0; i_topic < topic_titles.size(); i_topic++)
			if(result_matrix[i_student][i_topic])
			{
				std::cout <<  student_preferences_vec[i_student].first << " get the topic " << topic_titles[i_topic] << std::endl;
				break;
			}

	std::remove("topic_assignment.lp");
	std::remove("assignment_out.txt");

	return 0;
}
